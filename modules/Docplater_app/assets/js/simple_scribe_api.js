// Generated by LiveScript 1.4.0
(function(){
  var tags_allowed_for_normalization, x$;
  tags_allowed_for_normalization = {
    b: true,
    strong: true,
    i: true,
    em: true,
    u: true,
    s: true,
    strike: true,
    sup: true,
    sub: true
  };
  /**
   * Node contents normalization - will combine together similar nodes next to each other, will also merge child nodes of the same type into parent
   *
   * @param {Node} target_node
   */
  function normalize(target_node){
    var i$, ref$, node, j$, ref1$, len$, child_node, len1$;
    target_node.normalize();
    for (i$ = (ref$ = target_node.querySelectorAll('*')).length - 1; i$ >= 0; --i$) {
      node = ref$[i$];
      if (node.parentNode && node.nodeName === node.parentNode.nodeName && node.nodeName.toLowerCase() in tags_allowed_for_normalization) {
        for (j$ = 0, len$ = (ref1$ = node.childNodes).length; j$ < len$; ++j$) {
          child_node = ref1$[j$];
          node.insertBefore(child_node, node);
        }
        node.parentNode.removeChild(node);
      }
    }
    target_node.normalize();
    for (i$ = 0, len$ = (ref$ = target_node.querySelectorAll('*')).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (node.nextSibling) {
        if (node.nodeType === Node.TEXT_NODE) {
          if (!node.length) {
            node.parentNode.removeChild(node);
          }
        } else if (node.nodeType === node.nextSibling.nodeType && node.nodeName.toLowerCase() in tags_allowed_for_normalization) {
          for (j$ = 0, len1$ = (ref1$ = node.nextSibling.childNodes).length; j$ < len1$; ++j$) {
            child_node = ref1$[j$];
            node.appendChild(child_node);
          }
          node.nextSibling.parentNode.removeChild(node.nextSibling);
        }
      }
    }
  }
  /**
   * @param {Node} node
   *
   * @return {Element}
   */
  function get_container_element(node){
    if (node.nodeType === Node.TEXT_NODE) {
      return node.parentNode;
    } else {
      return node;
    }
  }
  /**
   * Will shrink specified parent to the range and return parts before range and after it
   *
   * @param {Element}	parent
   * @param {Range}	range
   *
   * {DocumentFragment[]} 2 fragments: before and after
   */
  function shrink_to_range(parent, range){
    var x$, range_1, y$, range_2, before, after;
    x$ = range_1 = new Range;
    x$.setStartBefore(parent.firstChild || parent);
    x$.setEnd(range.startContainer, range.startOffset);
    y$ = range_2 = new Range;
    y$.setStart(range.endContainer, range.endOffset);
    y$.setEndAfter(parent.lastChild || parent);
    before = range_1.extractContents();
    after = range_2.extractContents();
    return [before, after];
  }
  /**
   * @param {Element}	element
   * @param {string}	tag
   *
   * @return {Element}
   */
  function wrap_with_tag(element, tag){
    var tmp;
    tmp = document.createElement(tag);
    tmp.appendChild(element);
    return tmp;
  }
  /**
   * @param {Scribe} scribe_instance
   */
  function simple_scribe_api(scribe_instance){
    var fire_state_changed, destroyed, x$, y$, this$ = this;
    this.scribe_instance = scribe_instance;
    fire_state_changed = function(){
      this$.scribe_instance.trigger('scribe:state-changed');
    };
    destroyed = function(){
      var x$, y$;
      x$ = this.scribe_instance.el;
      x$.removeEventListener('keyup', fire_state_changed);
      x$.removeEventListener('mouseup', fire_state_changed);
      x$.removeEventListener('focus', fire_state_changed);
      x$.removeEventListener('blur', fire_state_changed);
      y$ = this.scribe_instance;
      y$.off('content-changed', fire_state_changed);
      y$.off('scribe:destroy', destroyed);
    };
    x$ = this.scribe_instance.el;
    x$.addEventListener('keyup', fire_state_changed);
    x$.addEventListener('mouseup', fire_state_changed);
    x$.addEventListener('focus', fire_state_changed);
    x$.addEventListener('blur', fire_state_changed);
    y$ = this.scribe_instance;
    y$.on('content-changed', fire_state_changed);
    y$.on('scribe:destroy', destroyed);
  }
  x$ = simple_scribe_api.prototype;
  /**
   * Subscribe to event when selection or content changes (not necessary actually changes, but likely so)
   *
   * @param {Function} callback
   */
  x$.on_state_changed = function(callback){
    this.scribe_instance.on('scribe:state-changed', callback);
  };
  /**
   * Unsubscribe from event, which was subscribed with `on_state_changed()` method
   *
   * @param {Function} callback
   */
  x$.off_state_changed = function(callback){
    this.scribe_instance.off('scribe:state-changed', callback);
  };
  /**
   * Convenient transactions wrapper on top of provided by Scribe
   * Main differences: returns value returned by callback, calls callbacks with `this`, ignores nested transactions within single parent transaction
   *
   * @param {Function}
   *
   * @return {*}
   */
  x$.transaction = function(callback){
    var result;
    if (this._in_transaction) {
      return callback.call(this);
    }
    this._in_transaction = true;
    this.scribe_instance.transactionManager.run(function(){
      result = callback.call(this);
    });
    this._in_transaction = false;
    return result;
  };
  /**
   * Returns selection and range from `Scribe.api.Selection`, but ensures that some text is selected (if not - selects parent element)
   *
   * @return {Object} With keys `selection` and `range`
   */
  x$.get_normalized_selection_and_range = function(){
    var ref$, selection, range, parent_element, x$, new_range, y$, z$, z1$;
    ref$ = new this.scribe_instance.api.Selection, selection = ref$.selection, range = ref$.range;
    if (range) {
      parent_element = get_container_element(range.commonAncestorContainer);
      if (!this.is_selected_text()) {
        x$ = new_range = new Range;
        x$.setStartBefore(parent_element.firstChild);
        x$.setEndAfter(parent_element.lastChild);
        range = new_range;
        y$ = selection;
        y$.removeAllRanges();
        y$.addRange(range);
      } else if (parent_element === this.scribe_instance.el) {
        parent_element = get_container_element(selection.anchorNode);
        if (parent_element !== this.scribe_instance.el) {
          z$ = new_range = new Range;
          z$.setStartBefore(parent_element.firstChild);
          z$.setEndAfter(parent_element.lastChild);
          range = new_range;
          z1$ = selection;
          z1$.removeAllRanges();
          z1$.addRange(range);
        }
      }
    }
    return {
      selection: selection,
      range: range
    };
  };
  /**
   * Whether text is selected in editor
   *
   * @return {bool}
   */
  x$.is_selected_text = function(){
    var range;
    range = (new this.scribe_instance.api.Selection).range;
    return Boolean(range && (range.startContainer !== range.endContainer || range.startOffset !== range.endOffset));
  };
  /**
   * Whether either no selection or selected text within the same element
   *
   * @return {bool}
   */
  x$.is_single_element_in_range = function(){
    var range;
    range = (new this.scribe_instance.api.Selection).range;
    return Boolean(range && range.startContainer === range.endContainer);
  };
  /**
   * Wrap selected content with element
   *
   * @param {Element} element
   *
   * @return {bool}
   */
  x$.wrap_selection_with_element = function(element){
    var this$ = this;
    return this.transaction(function(){
      var ref$, selection, range, parent_element, x$, new_range, y$;
      ref$ = this$.get_normalized_selection_and_range(), selection = ref$.selection, range = ref$.range;
      if (!range) {
        return false;
      }
      parent_element = get_container_element(range.commonAncestorContainer);
      element.appendChild(range.extractContents());
      range.insertNode(element);
      x$ = new_range = new Range;
      x$.setStartBefore(element.firstChild);
      x$.setEndAfter(element.lastChild);
      y$ = selection;
      y$.removeAllRanges();
      y$.addRange(new_range);
      normalize(parent_element);
      return true;
    });
  };
  /**
   * Wrap selected content with empty element of specified tag (wrapper for `wrap_selection_with_element`)
   *
   * @param {string} tag
   *
   * @return {bool}
   */
  x$.wrap_selection_with_tag = function(tag){
    return this.wrap_selection_with_element(document.createElement(tag));
  };
  /**
   * Unwrap selected content from specified tag
   *
   * @param {string} tag
   *
   * @return {bool}
   */
  x$.unwrap_selection_with_tag = function(tag){
    var this$ = this;
    return this.transaction(function(){
      var ref$, selection, range, parent_element, before, after, fragment, new_parent_element, new_range, x$, i$, len$, element, j$, ref1$, len1$, child_node, range_start, range_end, y$, z$;
      ref$ = this$.get_normalized_selection_and_range(), selection = ref$.selection, range = ref$.range;
      if (!range) {
        return false;
      }
      parent_element = get_container_element(range.commonAncestorContainer);
      ref$ = shrink_to_range(parent_element, range), before = ref$[0], after = ref$[1];
      fragment = range.extractContents();
      if (parent_element.matches(tag)) {
        before = wrap_with_tag(before, tag);
        after = wrap_with_tag(after, tag);
        fragment.insertBefore(before, fragment.firstChild);
        fragment.appendChild(after);
        new_parent_element = parent_element.parentNode;
        new_parent_element.replaceChild(fragment, parent_element);
        parent_element = new_parent_element;
        new_range = new Range;
        new_range.setStartAfter(before);
        new_range.setEndBefore(after);
        x$ = selection;
        x$.removeAllRanges();
        x$.addRange(new_range);
        if (!before.textContent.length) {
          before.parentNode.removeChild(before);
        }
        if (!after.textContent.length) {
          after.parentNode.removeChild(after);
        }
      } else {
        for (i$ = 0, len$ = (ref$ = fragment.querySelectorAll(tag)).length; i$ < len$; ++i$) {
          element = ref$[i$];
          for (j$ = 0, len1$ = (ref1$ = element.childNodes).length; j$ < len1$; ++j$) {
            child_node = ref1$[j$];
            element.parentNode.insertBefore(child_node, element);
          }
          element.parentNode.removeChild(element);
        }
        range_start = fragment.firstChild;
        range_end = fragment.lastChild;
        fragment.insertBefore(before, fragment.firstChild);
        fragment.appendChild(after);
        range.insertNode(fragment);
        y$ = new_range = new Range;
        y$.setStartBefore(range_start);
        y$.setEndAfter(range_end);
        z$ = selection;
        z$.removeAllRanges();
        z$.addRange(new_range);
      }
      normalize(parent_element);
      return true;
    });
  };
  /**
   * Whether selection is wrapped with specified tag
   *
   * @param {string} tag
   *
   * @return {bool}
   */
  x$.is_selection_wrapped_with_tag = function(tag){
    var range, parent_element;
    range = this.get_normalized_selection_and_range().range;
    if (!range) {
      return false;
    }
    parent_element = get_container_element(range.commonAncestorContainer);
    return parent_element.matches(tag + ", " + tag + " *");
  };
  /**
   * Toggle selection wrapping between two of the specified tags (if second tag not specified - wrap and unwrap single tag only)
   *
   * @param {string}				tag_1
   * @param {(string|undefined)}	tag_2
   */
  x$.toggle_selection_wrapping_with_tag = function(tag_1, tag_2){
    var this$ = this;
    this.transaction(function(){
      if (this$.is_selection_wrapped_with_tag(tag_1)) {
        this$.unwrap_selection_with_tag(tag_1);
        if (tag_2) {
          return this$.wrap_selection_with_tag(tag_2);
        }
      } else {
        if (tag_2) {
          this$.unwrap_selection_with_tag(tag_2);
        }
        return this$.wrap_selection_with_tag(tag_1);
      }
    });
  };
  /**
   * Insert element or document fragment, if some content is already selected - it will be replaced
   *
   * @param {(DocumentFragment|Element)} element
   *
   * @return {bool}
   */
  x$.insert_element = function(element){
    var range, this$ = this;
    range = (new this.scribe_instance.api.Selection).range;
    if (!range) {
      return false;
    }
    return this.transaction(function(){
      if (!this$.is_selected_text()) {
        range.deleteContents();
      }
      range.insertNode(element);
      return true;
    });
  };
  /**
   * Insert HTML content, if some content is already selected - it will be replaced
   *
   * @param {string} content
   *
   * @return {bool}
   */
  x$.insert_html = function(content){
    var range;
    range = (new this.scribe_instance.api.Selection).range;
    if (!range) {
      return false;
    }
    return this.insert_element(range.createContextualFragment(content));
  };
  (cs.Docplater || (cs.Docplater = {})).simple_scribe_api = simple_scribe_api;
}).call(this);
