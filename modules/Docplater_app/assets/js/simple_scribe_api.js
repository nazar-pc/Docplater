// Generated by LiveScript 1.4.0
/**
 * Node contents normalization - will combine together similar nodes next to each other, will also merge child nodes of the same type into parent
 *
 * @param {Node} target_node
 */
(function(){
  var x$;
  function normalize(target_node){
    var i$, ref$, node, j$, ref1$, len$, child_node, len1$;
    target_node.normalize();
    for (i$ = (ref$ = target_node.querySelectorAll('*')).length - 1; i$ >= 0; --i$) {
      node = ref$[i$];
      if (node.parentNode && node.nodeName === node.parentNode.nodeName && node.nodeName.indexOf('-') === -1) {
        for (j$ = 0, len$ = (ref1$ = node.childNodes).length; j$ < len$; ++j$) {
          child_node = ref1$[j$];
          node.insertBefore(child_node, node);
        }
        node.parentNode.removeChild(node);
      }
    }
    target_node.normalize();
    for (i$ = 0, len$ = (ref$ = target_node.querySelectorAll('*')).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (node.nextSibling) {
        if (node.nodeType === Node.TEXT_NODE) {
          if (!node.length) {
            node.parentNode.removeChild(node);
          }
        } else if (node.nodeType === node.nextSibling.nodeType && node.nodeName.indexOf('-') === -1) {
          for (j$ = 0, len1$ = (ref1$ = node.nextSibling.childNodes).length; j$ < len1$; ++j$) {
            child_node = ref1$[j$];
            node.appendChild(child_node);
          }
          node.nextSibling.parentNode.removeChild(node.nextSibling);
        }
      }
    }
  }
  /**
   * @param {Node} node
   *
   * @return {Element}
   */
  function get_container_element(node){
    if (node.nodeType === Node.TEXT_NODE) {
      return node.parentNode;
    } else {
      return node;
    }
  }
  /**
   * Will shrink specified parent to the range and return parts before range and after it
   *
   * @param {Element}	parent
   * @param {Range}	range
   *
   * {Element[]}
   */
  function shrink_to_range(parent, range){
    var range_1, range_2, before, after;
    range_1 = new Range;
    range_1.setStartBefore(parent.firstChild || parent);
    range_1.setEnd(range.startContainer, range.startOffset);
    range_2 = new Range;
    range_2.setStart(range.endContainer, range.endOffset);
    range_2.setEndAfter(parent.lastChild || parent);
    before = range_1.extractContents();
    after = range_2.extractContents();
    return [before, after];
  }
  /**
   * @param {Element}	element
   * @param {string}	tag
   *
   * @return {Element}
   */
  function wrap_with_tag(element, tag){
    var tmp;
    tmp = document.createElement(tag);
    tmp.appendChild(element);
    return tmp;
  }
  /**
   * @param {Scribe} scribe_instance
   */
  function simple_scribe_api(scribe_instance){

    this.scribe_instance = scribe_instance;
  }
  x$ = simple_scribe_api.prototype;
  /**
   * Whether text is selected in editor
   *
   * @return {bool}
   */
  x$.selected_text = function(){
    var range;
    range = (new this.scribe_instance.api.Selection).range;
    return Boolean(range && (range.startContainer !== range.endContainer || range.startOffset !== range.endOffset));
  };
  /**
   * Wrap selected content with element
   *
   * @param {Element} element
   *
   * @return {bool}
   */
  x$.wrap_selection_with_element = function(element){
    var range, parent_element;
    if (!this.selected_text()) {
      return false;
    }
    range = (new this.scribe_instance.api.Selection).range;
    parent_element = get_container_element(range.commonAncestorContainer);
    element.appendChild(range.extractContents());
    range.insertNode(element);
    normalize(parent_element);
    return true;
  };
  /**
   * Wrap selected content with empty element of specified tag (wrapper for `wrap_selection_with_element`)
   *
   * @param {string} tag
   *
   * @return {bool}
   */
  x$.wrap_selection_with_tag = function(tag){
    return this.wrap_selection_with_element(document.createElement(tag));
  };
  /**
   * Unwrap selected content from specified tag
   *
   * @param {string} tag
   *
   * @return {bool}
   */
  x$.unwrap_selection_with_tag = function(tag){
    var ref$, selection, range, parent_element, before, after, fragment, new_range, x$, i$, len$, element, j$, ref1$, len1$, child_node, range_start, range_end, y$;
    if (!this.selected_text()) {
      return false;
    }
    ref$ = new this.scribe_instance.api.Selection, selection = ref$.selection, range = ref$.range;
    parent_element = get_container_element(range.commonAncestorContainer);
    ref$ = shrink_to_range(parent_element, range), before = ref$[0], after = ref$[1];
    fragment = range.extractContents();
    if (parent_element.matches(tag)) {
      before = wrap_with_tag(before, tag);
      after = wrap_with_tag(after, tag);
      fragment.insertBefore(before, fragment.firstChild);
      fragment.appendChild(after);
      parent_element.parentNode.replaceChild(fragment, parent_element);
      new_range = new Range;
      new_range.setStartAfter(before);
      new_range.setEndBefore(after);
      x$ = selection;
      x$.removeAllRanges();
      x$.addRange(new_range);
    } else {
      for (i$ = 0, len$ = (ref$ = fragment.querySelectorAll(tag)).length; i$ < len$; ++i$) {
        element = ref$[i$];
        for (j$ = 0, len1$ = (ref1$ = element.childNodes).length; j$ < len1$; ++j$) {
          child_node = ref1$[j$];
          element.parentNode.insertBefore(child_node, element);
        }
        element.parentNode.removeChild(element);
      }
      range_start = fragment.firstChild;
      range_end = fragment.lastChild;
      fragment.insertBefore(before, fragment.firstChild);
      fragment.appendChild(after);
      range.insertNode(fragment);
      new_range = new Range;
      new_range.setStartBefore(range_start);
      new_range.setEndAfter(range_end);
      y$ = selection;
      y$.removeAllRanges();
      y$.addRange(new_range);
    }
    normalize(parent_element);
    return true;
  };
  (cs.Docplater || (cs.Docplater = {})).simple_scribe_api = simple_scribe_api;
}).call(this);
